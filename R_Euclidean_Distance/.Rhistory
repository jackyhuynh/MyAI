MyRData <- read.csv("Data.csv", header = TRUE)
MyRData <- read.csv("Data.csv", header = TRUE)
MyRData <- read.csv("Data.csv", header = TRUE)
View(MyRData)
MyRData
url <- "https://archive.ics.uci.edu/ml/machine-learning-databases/ionosphere/ionosphere.data"
df <- read_table(url, col_names=FALSE)
dplyr::glimpse(df)
library(readr)
url <- "https://archive.ics.uci.edu/ml/machine-learning-databases/ionosphere/ionosphere.data"
df <- read_table(url, col_names=FALSE)
dplyr::glimpse(df)
df <- read_table(url, col_names=FALSE)
install.packages("readr")
library(readr)
url <- "https://archive.ics.uci.edu/ml/machine-learning-databases/ionosphere/ionosphere.data"
df <- read_table(url, col_names=FALSE)
dplyr::glimpse(df)
install.packages("curl")
df <- read_table(url, col_names=FALSE)
dplyr::glimpse(df)
install.packages("dplyr")
dplyr::glimpse(df)
view (df)
View (df)
# define a probability density function P
P <- 1:10/sum(1:10)
# define a probability density function Q
Q <- 20:29/sum(20:29)
# combine P and Q as matrix object
x <- rbind(P,Q)
library(philentropy)
# compute the Euclidean Distance with default parameters
distance(x, method = "euclidean")
install.packages("Distance")
install.packages("philentropy")
library(philentropy)
# compute the Euclidean Distance with default parameters
distance(x, method = "euclidean")
View (x)
ProbMatrix <- rbind(1:10/sum(1:10), 20:29/sum(20:29),30:39/sum(30:39))
rownames(ProbMatrix) <- paste0("Example", 1:3)
# compute the euclidean distance between all
# pairwise comparisons of probability vectors
distance(ProbMatrix, method = "euclidean")
View (ProbMatrix)
#
MyRData %>% select(1:34)
library(tidyverse)
install.packages("tidyverse")
library(readr)
library(tidyverse)
# Using Excel to import the ionosphere.data into Data.csv
MyRData <- read.csv("Data.csv", header = TRUE)
#
View (MyRData)
#
MyRData %>% select(1:34)
View (MyRData)
#
MyRData<-MyRData %>% select(1:34)
View (MyRData)
distance(MyRData, method = "euclidean")
library(readr)
library(tidyverse)
library(philentropy)
# Using Excel to import the ionosphere.data into Data.csv
MyRData <- read.csv("Data.csv", header = TRUE)
# View the data to analyze
View (MyRData)
#Using only 34 continuous attributes for analyst
MyRData<-MyRData %>% select(1:34)
#apply the distance function to compute the
#L2 distance (Euclidean distance) between all pairs of data points.
distance(MyRData, method = "euclidean")
# Needed library
library(readr)
library(tidyverse)
library(philentropy)
# Using Excel to import the ionosphere.data into Data.csv
MyRData <- read.csv("Data.csv", header = TRUE)
# View the data to analyze
View (MyRData)
#Using only 34 continuous attributes for analyst
MyRData<-MyRData %>% select(1:34)
#apply the distance function to compute the
#L2 distance (Euclidean distance) between all pairs of data points.
distance(MyRData, method = "euclidean")
#apply the distance function to compute the
#L2 distance (Euclidean distance) between all pairs of data points.
distance(MyRData, method = "euclidean")
#apply the distance function to compute the
#L2 distance (Euclidean distance) between all pairs of data points.
distance(MyRData, method = "euclidean")
# Needed library
library(readr)
library(tidyverse)
library(philentropy)
# Using Excel to import the ionosphere.data into Data.csv
MyRData <- read.csv("Data.csv", header = TRUE)
# View the data to analyze
View (MyRData)
#Using only 34 continuous attributes for analyst
MyRData<-MyRData %>% select(1:34)
#apply the distance function to compute the
#L2 distance (Euclidean distance) between all pairs of data points.
distance(MyRData, method = "euclidean")
# Result of the first 10 pair
# Metric: 'euclidean'; comparing: 351 vectors.
#             v1       v2        v3       v4       v5        v6        v7       v8        v9
# v1   0.0000000 2.776359 1.1697276 4.772563 1.377347 3.0490724 1.5304711 4.803640 1.2050179
# v2   2.7763589 0.000000 3.3800330 4.454509 2.540531 2.7838832 2.7539302 4.859196 3.4724946
#           v10       v11      v12       v13      v14       v15      v16       v17      v18
# v1   3.564314 1.5055474 3.584336 1.3487913 3.113995 3.1023366 3.851302 2.2606502 6.728122
# v2   3.271473 3.4588373 5.073432 3.7733247 4.540863 4.8713059 2.901313 4.1755709 7.017637
# [ reached getOption("max.print") -- omitted 349 rows ]
knitr::opts_chunk$set(echo = TRUE)
# test chars, string, integer, and float
common_element(
c('T','b','c',11,12,54,67,'d','Y','t','u',1,2,3,4,5,6,7,8,9,9,1.1,3.4,7.99,'t','u','We will','it','none','cv','bl'),
c('t','T','T','t','q','U','c','T','D','d','A','T',8,9,11,12,12,'rock','it',"none",13,14,9,7.999,7.99))
# test chars, string
common_element(
c('T','b','c','d','Y','t','u','We will','it','none','cv','bl'),
c('t','T','T','t','q','U','c','T','D','d','A','T','We will','rock','it',"none"))
# test integer
common_element(
c(1,2,3,4,5,6,7,8,9,9),
c(8,9,11,12,12,13,14,9))
# create function common_element
# input: 2 vector of different size
# output: vector of common elements, return NULL if no common element
common_element <- function(x,y){
# the intersect base R return the common element between 2 vectors
z <- intersect(x, y)
return (z)
}
# test integer
common_element(
c(1,2,3,4,5,6,7,8,9,9),
c(8,9,11,12,12,13,14,9))
# test chars, string
common_element(
c('T','b','c','d','Y','t','u','We will','it','none','cv','bl'),
c('t','T','T','t','q','U','c','T','D','d','A','T','We will','rock','it',"none"))
# test chars, string, integer, and float
common_element(
c('T','b','c',11,12,54,67,'d','Y','t','u',1,2,3,4,5,6,7,8,9,9,1.1,3.4,7.99,'t','u','We will','it','none','cv','bl'),
c('t','T','T','t','q','U','c','T','D','d','A','T',8,9,11,12,12,'rock','it',"none",13,14,9,7.999,7.99))
update.packages(ask = FALSE, checkBuilt = TRUE)
tinytex::tlmgr_update()
